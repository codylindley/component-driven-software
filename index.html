<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
  <meta http-equiv="X-UA-Compatible" content="ie=edge" />
  <link rel="stylesheet" href="css/reset.css" />
  <link rel="stylesheet" href="css/styles.css" />
  <link rel="stylesheet" href="css/prism.css" />
  <link href="css/viewer.min.css" rel="stylesheet">
  <script src="js/prism.js"></script>
  <title>Component-driven Software</title>
</head>

<body>

  <div id="menu">

    <h3>Component-driven Software</h3>

    <div id="from"><a href="http://www.componentdrivensoftware.com/">componentdrivensoftware.com</a> by <a
        href="http://www.codylindley.com">Cody Lindley</a>
    </div>

    <div id="toc"></div>
  </div>

  <div id="panel">

    <div id="menuButton">|||</div>

    <div id="bookPadding">

      <h1>
        Component-driven Software
      </h1>

      <h3 style="margin-top:0px"><a href="http://www.componentdrivensoftware.com/">componentdrivensoftware.com</a> by <a
          href="http://www.codylindley.com">Cody Lindley</a></h3>
      <section>
        Component-driven Software is a catch-all term used to describe the methodologies and tools for subdividing part
        or all of an application into <a href="https://en.wikipedia.org/wiki/Composability">composable</a> <a
          href="https://blog.bitsrc.io/independent-components-the-webs-new-building-blocks-59c893ef0f65">independently</a>
        specified and managed presentational (i.e., UI components) and
        nonpresentational components. Components are built, versioned, and tested separately from application
        development concerns and in lockstep with Visual Design, Interaction Design, and User Experience design
        requirements to ensure UI quality and avoid difficult to maintain monolithic software applications.
      </section>

      <hr />

      <div id="chapter1" class="chapter">

        <h2>1 : Why Component-driven Software?</h2>

        <p>The following bullet points broadly explain why an organization might consider using a component-driven
          system and building
          component-driven software:</p>

        <ul>
          <li>
            Applications built from component tree architectures (e.g., Vue, React, Angular, etc.) can result in
            thousands of un-versioned built-as-needed undocumented and disorganized components resulting in monolithic
            front-end applications that are slow to build, have subpar UI's, have tightly coupled components, and are
            often difficult to maintain and scale. Ideally, what is needed is a system in which most if not all the
            components, especially UI components, become first-class citizens that are constructed in
            isolation, self-contained, versioned, and given the proper documentation and isolated testing routines.
          </li>
          <li>
            Front-end applications, as of late, are being developed by developers who are responsible for architecting
            the
            application, handling data retrieval, handling global state concerns, as well as constructing and testing
            all components
            within the application (including UI components). Front-end application developers
            carry too much
            workload when building user-centered, maintainable, cross-device, cross-platform, front-end
            applicationsâ€”this workload
            results in long, complicated development cycles. Application developers simply
            have too
            many responsibilities when it comes to building nontrivial applications. As a result, component management
            (especially
            UI components) can become a
            second-class citizen or afterthought to application
            developers.
            Ideally, the burden of application development needs to be distributed to UI developers who are focused on
            building,
            testing, and maintaining UI components in a walled-off garden while application developers can
            simultaneously be working
            on application concerns.
          </li>
          <li>
            Organizations all too often fail to set up the proper systems and owners around design practices and
            development practices that facilitate sophisticated abstractions and correctly scoped reusable materials.
            Ideally, organizations should erect "Design System(s)" that fuel a "Component-driven System" that fuels
            application development. These solutions require appropriately skilled owners that play a particular role
            within an organization's design and engineering practices.
          </li>
          <li>
            Organizations who are looking to separate their design system from implementations (e.g., <a
              href="https://spectrum.adobe.com/">Adobe Spectrum</a> is a design system, <a
              href="https://react-spectrum.adobe.com/">Adobe React Spectrum</a> is an implementation).
          </li>
          <li>
            Organizations have realized or felt the empty promises of top-down components and seek a solution to build
            applications with bottom-up domain (complex) and primitive (simple) components instead of premature generic
            components that
            have
            too wide of a purpose and API surfaces due to crosscutting concerns.
          </li>
          <li>Organizations know the value of back-end and front-end micro-series that separate applications into
            multiple isolated applications and want continue this trend by breaking an application
            into isolated independent components.</li>
        </ul>

      </div>

      <div id="chapter2" class="chapter">

        <h2>2 : Component-driven Software Tenants</h2>

        <p>There is no one way to go about doing component-driven software or constructing a component-driven system. No
          two
          organizations are exactly alike, and as such, no two organizations will solve the same problems in the same
          way. Thus,
          no two organizations will erect the same component-driven system. This makes prescribing any single canonical
          component-driven system complicated. However, there are some foundational tenets of building component-driven
          software
          which component-driven systems will commonly embody.</p>

        <p>Common tenets of a component-driven system are:</p>

        <ul>
          <li>Components get developed in isolation, tested in isolation, and are <a
              href="https://blog.bitsrc.io/independent-components-the-webs-new-building-blocks-59c893ef0f65">independently</a>
            versioned using <a href="https://semver.org/">semantic versioning</a>.
          </li>
          <li>Components become individual packages and get distributed using a public or private module repository
            (e.g., npm) for installing and uninstalling versioned module packages.</li>
          <li>Component-driven systems are engineered so that components within the system can be consumed to create
            other richer components within the system (i.e., Domain UI components are composed of Primitive UI
            components or said another way, Primitive UI components can be gathered together in order to produce Domain
            UI components).</li>
          <li>Components are a separate concern from the concerns of application architecture and
            application development.</li>
          <li>Components will undergo isolated unit testing (e.g., Jest), visually testing (e.g., Percy), and
            functional testing (e.g.,
            Cypress) before they are consumed into an application runtime. Applications then test the implementation of
            a component, not the component itself.</li>
          <li>UI components are extracted from feature specifications by designers (worse case developers) and specified
            separately as component specifications.</li>
          <li>Components are viewed as a game of composition. When components, especially bottom-up UI components, are
            view in
            this way application developers can build the bulk of an application from <a
              href="https://codylindley.github.io/locuslabs-storybook/?path=/story/mol-components-desktop-domain-components-building-level-selector--with-selected-building">precisely
              pre-built, heavily
              documented, and pre-test UI components</a> that have fallen out of traditional UI mockups/screens and
            business
            requirements. </li>
        </ul>

        <p>Disregarding one of the tenets mentioned above will erode the value of a component-driven systems relatively
          quickly.</p>

      </div>

      <div id="chapter3" class="chapter">

        <h2>3 : Component-driven Systems</h2>

        <p>Component-driven software is built from a component-driven system. A component-driven system is a system
          instituted by an organization that defines and facilitates the <strong>goals</strong>,
          <strong>strategies-architectures</strong>,
          <strong>roles-processes-assets</strong>,
          and <strong>tools</strong> used by
          the organization to birth and nurture <a
            href="https://blog.bitsrc.io/independent-components-the-webs-new-building-blocks-59c893ef0f65">independently</a>
          built components.
        </p>

        <h3>3.1 : Goals</h3>

        <p>
          Before adopting component-driven software practices, an organization should get all the stakeholders in
          alignment (i.e., Product, Design, Engineer)
          on the
          goals of adopting such a methodology. Start by prioritizing a list of goals
          and
          then make
          strategic & architectural decision's based on the list of goals.
        </p>

        <p><strong>What are your goals:</strong>
          Speed development? Fortify the quality of the user interface and the user experience? Reuse? Visual
          unification? Behavioral Unification? Experiential Unification?
          Separate application development from UI development? Avoid monolithic unmaintainable applications that have
          to be re-built too often?
        </p>

        <h3>3.2 : Strategies & Architectures</h3>

        <p>After an organization has a set of priorities goals, it will then need to use these goals to decide upon a
          component
          strategy and
          architecture.</p>

        <p><strong>Answer the following questions:</strong>
          Do you need top-down components, bottom-up, or both?
          Will you build UI components and nonpresentational components? Will you build primitive UI
          components as well as domain UI components. How will you organize your component sets? By product/application?
          By device? By platform? By all three? Is a Design System required? How does the Design System
          fuel the components? Will the component sets need to be
          themeable?
        </p>

        <h3>3.3 : Roles & Processes & Assets</h3>

        <p>With a set of goals and a component strategy & architecture defined, the design and engineering groups will
          next
          have
          to determine a design and development process for building independent components.</p>

        <p>
          <strong>Determine:</strong> How will components be defined? When will components be defined? How will updates
          to
          components be managed? How does this fit into
          your development process that exists today? Do component collections accept contributions? Who is responsible
          for defining components (designer, developers, both?). Who is responsible for building and
          documenting
          components (UI developers, application developers, both?). Who is responsible for maintaining the component
          specifications and component implementations? Will you build a focused team around components? Will the team
          have transient contributors or focused permanent full-time roles?
        </p>

        <h3>3.4 : Tools</h3>

        <p>The last part of a component-driven system will involve selecting a set of tools and then implementing the
          tools so that
          independent components can be built, maintained, and shared within an organization. These tools can be divided
          into
          three categories, "Design Tools," "Component Tools," and "Development Tools."</p>

        <p><strong>Design Tools:</strong></p>

        <p>Various design tools are available for specifying components and developing/managing design systems. I'd
          mention several
          options except that, in my opinion, Figma is the obvious choice for supporting component-driven systems. Here
          is why:

          Here is why:</p>

        <ul>
          <li>
            Figma files can be embedded into component-driven systems (e.g., using the <a
              href="https://storybook.js.org/addons/storybook-addon-designs/">Storybook Designs addon</a> you can add
            Figma for display directly when storybook when viewing a component)
          </li>
          <li>Figma has inline commenting/feedback system.</li>
          <li>Figma allows more than one editor at a time, which facilitates real-time collaborations.</li>
          <li>Figma offers a rich set of features and plugins for authors of Design Systems.</li>
          <li>Figma is web-based.</li>
        </ul>

        <p><strong>Component Tools:</strong></p>

        <p>Components are typically constructed using React/Preact (e.g., <a
            href="https://react-spectrum.adobe.com/">React Spectrum</a> ), Vue (e.g., <a
            href="https://vuetifyjs.com/">Vuetify</a>), Angular (e.g., <a href="https://material.angular.io/">Material
            Angular</a>), Web Components (e.g., <a href="https://shoelace.style/">shoelace</a>), or HTML & CSS (e.g., <a
            href="https://opensource.adobe.com/spectrum-css/">Spectrum CSS</a>).
          Depending upon which tool you use, each comes with a vast ecosystem of sub-tools, communities, and plugins.
        </p>

        <p><strong>Development Tools:</strong></p>

        <p>Two distinct tooling paths are available today that aid developers when developing <a
            href="https://blog.bitsrc.io/independent-components-the-webs-new-building-blocks-59c893ef0f65">independent
            components</a>.</p>

        <p>The first path entails using a tailored conglomeration of distinctly different tools that, as a whole, will
          provide the means to
          create and distribute independent components using a <a
            href="https://en.wikipedia.org/wiki/Monorepo">monorepo.</a>
        </p>

        <p>A basic tailored conglomeration of tools would be:</p>

        <ul>
          <li>
            <a href="https://www.npmjs.com/">NPM Registry</a>
            <ul>
              <li><a href="https://www.npmjs.com/search?q=%40locus-labs">NPM Organization</a></li>
            </ul>
          </li>
          <li>
            <a href="https://classic.yarnpkg.com/en/">Yarn</a>
            <ul>
              <li><a href="https://classic.yarnpkg.com/en/docs/yarn-workflow">Yarn Workspaces</a></li>
              <li><a href="https://classic.yarnpkg.com/en/docs/cli/run">Yarn Run</a></li>
            </ul>
          </li>
          <li><a href="https://github.com/lerna/lerna#readme">Lerna</a></li>
          <li><a href="https://storybook.js.org/">Storybook</a>
            <ul>
              <li><a href="https://mdxjs.com/">MDX</a></li>
            </ul>
          </li>
          <li>
            <a href="https://rollupjs.org/guide/en/">Rollup</a>
            <ul>
              <li><a href="https://rollupjs.org/guide/en/#babel">Babel</a></li>
            </ul>
          </li>
        </ul>

        <p>The second path would be to use an off-the-shelf, all-in-one tool constructed precisely for building
          component-driven
          software. <a href="https://harmony-docs.bit.dev/essentials/what-is-bit">Bit</a> (specifically <a
            href="https://harmony-docs.bit.dev/">Bit Harmony</a>)
          is currently the only product offering
          in
          this space that does
          most of what option one offers but with enterprise features. I like to
          think of Bit as a node app
          that can replace the majority of the tools from the previous path mentioned but with the added bonus of <a
            href="https://bit.dev/">Bit.dev</a>. Bit.dev is
          where Bit
          components can be publicly or privately hosted, shared, and composed. Consider Bit.dev like a
          global Storybook in the cloud where anyone can place a collection of runnable components that are aware of all
          other collections of components within the cloud. </p>

        <p>Below are some bullet points articulating what Bit does really well v.s. curating a conglomerated system of
          separate tools.</p>

        <ol>
          <li>
            Bit will version not just every release of the component itself (i.e. an npm sermver) but also the
            historical artifacts that
            support the component (e.g., source code, builds, compositions, logs, docs, etc...). In a sense, Bit
            Harmony is a content versioning system for independent
            components. Bit manages development history, and it allows you to go back in time and review previous
            versions of the
            component package.
          </li>
          <li>Bit conceals the complexities of Yarn workspaces, Lerna, Babel, npm, and build tools.</li>
          <li>Bit offers Bit.dev, a place to immediately host, share, and collaborate on components.</li>
          <li>Bit works with presentational components as well as non-presentational components. In other words, it does
            not assume you only want to build UI components.</li>
          <li>Bit <a href="https://harmony-docs.bit.dev/aspects/dependency-resolver/">handles the dependencies</a> for
            independent components.</li>
          <li>Bit, if fully adopted (i.e., bit.dev workspaces) can also continuously release a component to anyone who
            consumes/composes it via
            Bit.dev</li>
        </ol>

      </div>


      <div id="chapter4" class="chapter">

        <h2>4 : LocusLabs Use Case</h2>

        <h3>4.1 : Overview</h3>

        <p>In March 2020, I was hired by the <a href="https://www.linkedin.com/in/jeff-goldberg-814828/">CTO</a> and <a
            href="https://www.linkedin.com/in/jmcminn/">VP of Product</a> from LocusLabs to orchestrate a
          component-driven
          software practice with the <a href="https://www.linkedin.com/in/sam-atmore/">design lead</a>. What is
          described below is the component-driven system we built for Locuslabs.</p>

        <div class="notes">

          <p>
            <strong>Note:</strong>
          </p>
          <ol>
            <li>
              As you read this use case, keep in mind that the decisions for the system were unique to LocusLabs. Note
              that
              LocusLabs built several different types of applications running
              on various devices (Kiosks, Large Displays, Desktops & Laptops, Tablets, and Mobile phones) used or viewed
              by
              various
              types of users (i.e. stationary users viewing only, walking users viewing only, kiosk touch users,
              desktop/laptop mouse users, mobile phone touch users).
            </li>
            <li>The system built for Locuslabs is not a general
              prescription for other organizations. Use this use case as an example of the scope and practice of
              creating
              component-driven systems.</li>
          </ol>
        </div>



        <h3>4.2 : Goals</h3>

        <p>The leadership from product, design, and engineering
          agreed on the following component-driven goals:</p>

        <ol>
          <li>
            Produce as much of the UI as possible for any given product/application in conjunction with design in the
            form of UI components so application developers can focus on application development and not UI development.
          </li>
          <li>Have unchangeable UI integrity (i.e. cemented visual design, behavioral design, interaction design) baked
            into the components before
            they are implemented.</li>
          <li>Speed the development and UI quality of products/applications by creating a new engineering group that
            focused on the
            development and testing of UI components that had been specified in detail by the design team using
            component specifications.</li>
        </ol>

        <h3>4.3 : Strategies & Architectures</h3>

        <p>The following strategies and component architecture were agreed upon by all parties involved so that the
          component-driven goals could be achieved:</p>

        <ul>
          <li><a
              href="https://codylindley.github.io/locuslabs-storybook/?path=/story/ui-component-system-overview-introduction--page">Build
              bottom-up stateless React UI components</a> for <a
              href="https://github.com/codylindley/locuslabs-component-driven-system/tree/master/ui_components">each
              product/application</a> (individually versioned and packaged).</li>
          <li>Each product/application would use its own design system.</li>
          <li>The component collections will be organized by product > device (optional) > composability (primitive v.s.
            domain).</li>
          <li>Component re-use only occurs internally within each product/application. In no way did
            products/applications share components externally. The cost to repeat oneself was trivial compared to the
            risks of any type of top-down components tightly coupling products together or complicating component
            development and design.</li>
          <li>Each component set will use a <a
              href="https://github.com/codylindley/locuslabs-component-driven-system/blob/master/ui_components/MOL/desktop/themes/mol-desktop-default-theme/index.js">component
              theme (also an independent component)</a>
            that can be overridden (i.e. customizable design tokens from the design system).</li>
        </ul>

        <p>An example collection of components for a product called "Maps Online" would be:</p>


        <ul>
          <li>Maps Online Desktop/Tablet Components:<ul>
              <li>domain<ul>
                  <li>componentA</li>
                  <li>componentB</li>
                  <li>etc</li>
                </ul>
              </li>
              <li>primitive<ul>
                  <li>componentA</li>
                  <li>componentB</li>
                  <li>etc</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>Maps Online Mobile Components:<ul>
              <li>domain<ul>
                  <li>componentA</li>
                  <li>componentB</li>
                  <li>etc</li>
                </ul>
              </li>
              <li>primitive<ul>
                  <li>componentA</li>
                  <li>componentB</li>
                  <li>etc</li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>


        <p>Laboring an agreed upon strategy and architecture was not an easy feat. It took weeks of conversations and
          focusing on the goals to arrive at an agreed upon idea of what to build and how to build it.</p>

        <p>Below are a few of the diagrams that were used when discussing and settling on the correct component strategy
          and
          architecture:</p>

        <div class="images">

          <div class="item"><img src="img/option1.png"></div>

          <div class="item"><img src="img/option2.png"></div>

          <div class="item"><img src="img/option3.png"></div>

          <div class="item"><img src="img/option4.png"></div>

          <div class="item"><img src="img/option5.png"></div>

          <div class="item"><img src="img/a.png"></div>

          <div class="item"><img src="img/b.png"></div>

          <div class="item"><img src="img/d.png"></div>

        </div>

        <h3>4.4 : Roles & Processes & Assets</h3>

        <p>A new engineering group was formed within the LocusLabs made up of two full-time
          front-end UI
          engineers and one <a href="https://www.linkedin.com/in/codylindley/">front-end UI engineer lead</a>. The team
          was called the "UI Component Dev Team". The lead
          worked with designs from the design team to build out a component-driven
          process and a component specification template that would produce a collection of bottom-up components for
          each
          product.
        </p>

        <p>The process:</p>

        <div class="image">
          <img src="img/c.png">
        </div>

        <p>The component specification template:</p>


        <div class="images">

          <div class="item"><img src="img/template.png"></div>

          <div class="item"><img src="img/x.png"></div>

        </div>

        <p>The component development process worked as follows. Each
          product/application would be built out according to the business/product requirements using standard screen
          mockups
          which visually defined the features of the product/application.</p>

        <p>For example, below is part of the feature specification representing the building level selector feature in
          the Maps Online
          product (i.e. a high fidelity screen mockup):
        </p>

        <div class="image">
          <img src="img/e.png">
        </div>

        <p>After feature specifications were completed for an entire product/application the design team would
          componentize the mockups into components
          (with the help of the component dev team)
          and then
          specify each component outside of the feature specifications (i.e.
          letting the component specifications fall out of the feature specifications).</p>

        <p>For example, below is the building level selector domain components specification as well as the primitive
          component specs that helped composed the building level selector domain component:</p>

        <div class="image">
          <img src="img/f.png">
        </div>

        <div class="images">

          <div class="item"><img src="img/g.png"></div>

          <div class="item"><img src="img/i.png"></div>

          <div class="item"><img src="img/j.png"></div>

        </div>

        <div class="notes">

          <p>
            <strong>Note:</strong>
          </p>
          <ol>
            <li>
              Component specifications could also define their <a
                href="https://github.com/codylindley/locuslabs-component-driven-system/tree/master/ui_components/MOL/desktop/components/building-level-selector">own
                internal sub-components</a> that we called component facets.
              Facets are components that required individual specifications, in order to stay organized, but were not
              intended for
              use by an application engineer, only a component developer.
              For example, in the building level selector component specification above the four internal components
              were specified as internal components (i.e. Level Row, Building Row, Search Results Indicator, Collapsed
              Tripper).
            </li>
          </ol>
        </div>

        <p>Once component specifications had been indicated as complete by the designers the engineers from the UI
          component dev team would
          take the specifications and build out the components and create the automated visual and functional test for
          each
          component using the tools decided upon by the teams lead UI engineer:</p>

        <p>For example here is the built <a
            href="https://codylindley.github.io/locuslabs-storybook/?path=/story/mol-components-desktop-domain-components-building-level-selector--with-selected-building">domain
            building level selector component</a> inside of Storybook:</p>

        <div class="images">

          <div class="item"><img src="img/h.png"></div>

          <div class="item"><img src="img/k.png"></div>

          <div class="item"><img src="img/l.png"></div>

        </div>

        <p>When a component was released as an npm package it became consumable by application developers. When enough
          of the
          components were design complete the application developers would then take the
          feature specifications and components and build component
          driven software.</p>

        <h3>4.5 : Tools</h3>


        <p>Briefly, components were developed, documented, and shared using <a
            href="https://codylindley.github.io/locuslabs-storybook/?path=/story/ui-component-system-overview-introduction--page">Storybook</a>
          from a monorepo (i.e. <a href="https://classic.yarnpkg.com/en/docs/workspaces/">yarn workspaces</a>) that
          housed
          all the <a href="https://www.npmjs.com/search?q=%40locus-labs">npm component packages</a>. Component stories
          within
          storybook were considered test cases for the components interface (i.e., React props) and "tests cases" were
          verified using <a href="https://docs.percy.io/docs/storybook">Percy</a> and <a
            href="https://github.com/NicholasBoll/cypress-storybook">Cypress</a> storybook plugins via Gitlabs
          CI/CD automation tools (e.g., visual testing and functional testing on every commit to a development branch in
          Git). </p>

        <p>Components
          were individually distributed to application developers from <a
            href="https://www.npmjs.com/search?q=%40locus-labs">the npm registry</a> with the help of Lerna. Once a
          component was available from the npm registry the documentation pages for each component would verify the
          components basic usage via <a
            href="https://codesandbox.io/dashboard/all/?workspace=a1d2b3f3-7ff5-44ef-a529-595fbcd81f1b">codesandbox</a>
          demo (also used an automated cypress test, to test all the codesandbox demos).
        </p>

        <p>Make no mistake about it orchestrating a set of standalone tools to manage collections of independently
          version
          components as well as defining how components are built, documented, and tested is no trivial matter. For a
          better understanding of the implications you can review the <a
            href="https://github.com/codylindley/locuslabs-component-driven-system">monorepo for the LocusLabs
            components</a>.</p>

        <p>Below are a list of the tools that were used to orchestrate the development, management, testing, and
          distribution of LocusLabs UI components:</p>

        <p><strong>Design System, Feature Specifications, Component Specifications</strong></p>

        <ul>
          <li><a href="https://www.figma.com/">Figma</a></li>
        </ul>

        <p><strong>CI/CD</strong></p>

        <ul data-sourcepos="45:1-49:0" dir="auto">
          <li data-sourcepos="45:1-49:0">Gitlab
            <ul data-sourcepos="46:3-49:0">
              <li data-sourcepos="46:3-49:0">
                <a href="https://docs.gitlab.com/ee/ci/README.html">Gitlab
                  CI/CD</a>
                <ul data-sourcepos="47:5-49:0">
                  <li data-sourcepos="47:5-49:0">
                    <a href="http://docker.com/">Docker</a>
                    <ul data-sourcepos="48:7-49:0">
                      <li data-sourcepos="48:7-49:0"><a href="https://hub.docker.com/r/cypress/base/">cypress/base</a>
                      </li>
                    </ul>
                  </li>
                </ul>
              </li>
            </ul>
          </li>
        </ul>

        <p><strong>Component Delivery</strong></p>

        <ul data-sourcepos="52:1-54:0" dir="auto">
          <li data-sourcepos="52:1-54:0">
            <a href="https://www.npmjs.com/">NPM Registry</a>
            <ul data-sourcepos="53:3-54:0">
              <li data-sourcepos="53:3-54:0"><a href="https://www.npmjs.com/search?q=%40locus-labs">NPM Organization</a>
              </li>
            </ul>
          </li>
        </ul>

        <p><strong>Development</strong></p>

        <ul data-sourcepos="57:1-65:0" dir="auto">
          <li data-sourcepos="57:1-57:32"><a href="https://nodejs.org/en/">Node</a></li>
          <li data-sourcepos="58:1-60:59">
            <a href="https://classic.yarnpkg.com/en/">Yarn 1</a>
            <ul data-sourcepos="59:3-60:59">
              <li data-sourcepos="59:3-59:72"><a href="https://classic.yarnpkg.com/en/docs/yarn-workflow">Yarn
                  Workspaces</a></li>
              <li data-sourcepos="60:3-60:59"><a href="https://classic.yarnpkg.com/en/docs/cli/run">Yarn Run</a></li>
            </ul>
          </li>
          <li data-sourcepos="61:1-61:48"><a href="https://github.com/lerna/lerna#readme">Lerna</a></li>
          <li data-sourcepos="62:1-62:85"><a
              href="https://storybook.js.org/docs/react/get-started/introduction">Storybook for React</a></li>
          <li data-sourcepos="63:1-65:0">
            <a href="https://rollupjs.org/guide/en/">Rollup</a>
            <ul data-sourcepos="64:3-65:0">
              <li data-sourcepos="64:3-65:0"><a href="https://rollupjs.org/guide/en/#babel">Babel</a></li>
            </ul>
          </li>
        </ul>

        <p><strong>UI Components</strong></p>

        <ul data-sourcepos="68:1-75:0" dir="auto">
          <li data-sourcepos="68:1-70:56">
            <a href="https://reactjs.org/">React</a>
            <ul data-sourcepos="69:3-70:56">
              <li data-sourcepos="69:3-69:56"><a href="https://github.com/facebook/prop-types">prop-types</a></li>
              <li data-sourcepos="70:3-70:56"><a href="https://www.npmjs.com/package/react-dom">react-dom</a></li>
            </ul>
          </li>
          <li data-sourcepos="71:1-71:53"><a href="https://styled-components.com/">Styled Components</a></li>
          <li data-sourcepos="72:1-72:45"><a href="https://styled-system.com/">Styled System</a></li>
          <li data-sourcepos="73:1-73:30"><a href="https://reakit.io/">ReaKit</a></li>
          <li data-sourcepos="74:1-75:0"><a href="https://polished.js.org/">Polished</a></li>
        </ul>

        <p><strong>Documentation & Demos</strong></p>

        <ul data-sourcepos="78:1-81:0" dir="auto">
          <li data-sourcepos="78:1-78:90">
            <a href="https://mdxjs.com/">MDX</a> (via <a
              href="https://storybook.js.org/docs/react/api/mdx">Storybook</a>)
          </li>
          <li data-sourcepos="79:1-79:105"><a
              href="https://codesandbox.io/dashboard/all/?workspace=a1d2b3f3-7ff5-44ef-a529-595fbcd81f1b">codesandbox.com</a>
          </li>
          <li data-sourcepos="80:1-81:0"><a href="https://shields.io/category/version">shields.io</a></li>
          <li data-sourcepos="80:1-81:0"><a href="https://npmfs.com/">npmfs.com</a></li>
        </ul>

        <p><strong>Testing & Quality</strong></p>

        <ul data-sourcepos="84:1-92:0" dir="auto">
          <li data-sourcepos="84:1-84:31"><a href="https://eslint.org/">ESLint</a></li>
          <li data-sourcepos="85:1-85:34"><a href="https://prettier.io/">Prettier</a></li>
          <li data-sourcepos="86:1-86:36"><a href="https://stylelint.io/">StyleLint</a></li>
          <li data-sourcepos="87:1-87:46"><a href="https://typicode.github.io/husky/#/">Husky</a></li>
          <li data-sourcepos="88:1-89:60">
            <a href="https://percy.io/">Percy</a>
            <ul data-sourcepos="89:3-89:60">
              <li data-sourcepos="89:3-89:60"><a href="https://docs.percy.io/docs/storybook">@percy/storybook</a></li>
            </ul>
          </li>
          <li data-sourcepos="90:1-92:0">
            <a href="https://www.cypress.io/">Cypress</a>
            <ul data-sourcepos="91:3-92:0">
              <li data-sourcepos="91:3-92:0"><a
                  href="https://github.com/NicholasBoll/cypress-storybook">cypress-storybook</a></li>
            </ul>
          </li>
        </ul>

      </div>

      <div id="chapter5" class="chapter">

        <h2>Prior Art</h2>

        <h3>Canonical example of a Design System and its implementations</h3>


        <p>
          Design System: <a href="https://spectrum.adobe.com/">Spectrum</a><br>
          Implementations: <a href="https://opensource.adobe.com/spectrum-css/">Spectrum CSS</a>, <a
            href="https://react-spectrum.adobe.com/react-spectrum/index.html">React Spectrum</a>, <a
            href="https://react-spectrum.adobe.com/react-aria/index.html">React Aria</a>, <a
            href="https://react-spectrum.adobe.com/react-stately/index.html">React Stately</a>
        </p>

        <h3>Examples of top-down generic component collections</h3>

        <p>
          Use the examples below as model on which to construct your
          own set of bottom-up components specific to your product or application.
        </p>

        <ul>
          <li><a href="https://ant.design/components/overview/" target="_blank" rel="nofollow noopener noreferrer"
              class="sbdocs sbdocs-a css-19nbuh3">Ant Design</a></li>
          <li><a href="https://seeds.sproutsocial.com/components/" target="_blank" rel="nofollow noopener noreferrer"
              class="sbdocs sbdocs-a css-19nbuh3">Racine</a></li>
          <li><a href="https://material-ui.com/" target="_blank" rel="nofollow noopener noreferrer"
              class="sbdocs sbdocs-a css-19nbuh3">Material-UI</a></li>
          <li><a href="https://chakra-ui.com/" target="_blank" rel="nofollow noopener noreferrer"
              class="sbdocs sbdocs-a css-19nbuh3">Chakra</a></li>
          <li><a href="https://www.welcome-ui.com/" target="_blank" rel="nofollow noopener noreferrer"
              class="sbdocs sbdocs-a css-19nbuh3">WUI</a></li>
          <li><a href="https://blueprintjs.com/docs/" target="_blank" rel="nofollow noopener noreferrer"
              class="sbdocs sbdocs-a css-19nbuh3">Blueprint</a></li>
          <li><a href="https://bold.bridge.ufsc.br/en/" target="_blank" rel="nofollow noopener noreferrer"
              class="sbdocs sbdocs-a css-19nbuh3">Bold</a></li>
          <li><a href="https://baseweb.design/" target="_blank" rel="nofollow noopener noreferrer"
              class="sbdocs sbdocs-a css-19nbuh3">Base</a></li>
          <li><a href="https://react-spectrum.adobe.com/react-spectrum/index.html" target="_blank"
              rel="nofollow noopener noreferrer" class="sbdocs sbdocs-a css-19nbuh3">Spectrum</a></li>
        </ul>

        <h3>Examples of bottom-up component collections</h3>

        <ul>
          <li><a
              href="https://codylindley.github.io/locuslabs-storybook/?path=/story/ui-component-system-overview-introduction--page">LocusLabs
              Storybook (Note: houses four bottom up component sets)</a></li>
        </ul>

        <h3>Articles</h3>

        <ul>
          <li><a href="https://www.componentdriven.org/">Component Driven User Interfaces</a> &amp; <a
              href="https://www.chromatic.com/blog/component-driven-development/">Component-Driven
              Development</a></li>
          <li><a href="https://www.component-driven.dev/">Component-Driven</a></li>
          <li><a href="https://bradfrost.com/blog/post/atomic-web-design/">Atomic Design</a></li>
          <li><a href="https://devblogs.microsoft.com/startups/building-micro-frontends-with-components/">Building Micro
              Frontends with Components</a></li>
          <li><a
              href="https://blog.bitsrc.io/independent-components-the-webs-new-building-blocks-59c893ef0f65">Independent
              Components: The Webâ€™s New Building Blocks</a></li>
          <li><a
              href="https://betterprogramming.pub/bit-harmony-a-new-tool-to-create-and-collaborate-on-independent-node-js-components-f871658edcb6">Bit
              Harmony: A New Tool To Create and Collaborate on Independent Node.js Components</a></li>
        </ul>

        <h3>Talks</h3>

        <ul>
          <li><a href="https://www.youtube.com/watch?v=yDjTcBKXKDE&amp;t=2s">Build Components Not
              Apps</a></li>
          <li><a href="https://www.youtube.com/watch?v=NiPW4gNLHuw">Going Component Driven with Gert Hengeveld at the
              Developers.nl TechNight</a></li>
        </ul>
      </div>

      <div id="chapter6" class="chapter">

        <h2>Terms</h2>

        <h3>Application Runtime</h3>

        <p>When the source code for an application is executed and the application is running (e.g., if you use React
          then the runtime is when the web platform takes source code and runs it to produce a running application
          in a web browser).</p>

        <h3>Bottom-up Components</h3>

        <p>A collection of custom-built components the when implemented, are intended to construct a known and already
          specified set of feature specifications within a product/application. Implementing and adopting these
          components is trivial because components are constructed specifically for a product or application from the
          design team (typically using a design system). Think of bottom-up components as the result of breaking down a
          product or application into primitive and domain components that have been precisely designed for the product
          or application.</p>

        <h3>Component</h3>

        <p>"A component is any group of files that serve a single purpose. That can be a React component, a Vue
          component, a Node.JS
          module, a CSS component, etc. Each of these can be of different levels of complexity and concreteness. For
          example, a
          component can be a full page or a simple UI element. It can be a small utility function or an entire
          microservice." - from <a
            href="https://blog.bitsrc.io/independent-components-the-webs-new-building-blocks-59c893ef0f65">"Independent
            Components: The Webâ€™s New Building Blocks"</a></p>

        <h3>Component-driven software</h3>

        <p>Catch-all term used to describe the methodologies and tools for subdividing part or all of an application
          into <a href="https://en.wikipedia.org/wiki/Composability">composable</a> <a
            href="https://blog.bitsrc.io/independent-components-the-webs-new-building-blocks-59c893ef0f65">independently</a>
          specified and managed presentational (i.e., UI components) and nonpresentational composable
          components. The components are built, versioned, and tested separately from application development concerns
          and design concerns to ensure quality and avoid monolithic software applications.</p>

        <h3>Component-driven system </h3>

        <p>A systematic plan instituted by an organization made up of the goals, strategies-architectures,
          roles-processes-assets, and tools leveraged by an organization in order to birth and nurture components for
          component-driven software applications.</p>

        <h3>Component Integration</h3>

        <p>When application developers take an external component and intergrade it into the source code for a given
          application. Typically, application developers will install a component then use the component.</p>

        <h3>Component Specifications </h3>

        <p>Refers to a specification created by designers explicitly scoped to the details of a component alone.
          Component specifications typically fall out of feature specifications.</p>

        <h3>Design System</h3>

        <p>A set of reusable design-related rules (tokens, patterns, behaviors, language) as a system of instructions
          that can fuel various implementations. Design systems are the fuel used to create component implementations.
        </p>

        <h3>Domain UI/Presentational Components</h3>

        <p>A component, typically constructed for a specific application or product that does not have any obvious UI
          reuse but exists to provide application developers with more
          than just simplistic and generic reusable components (i.e., a unique view or specific "organism/molecule" to
          borrow from Atomic Design). These components are often complex and take up a lot of the user's attention and
          view within a user interface (e.g., an entire header or footer or a complex domain-specific search UI).</p>

        <h3>Feature Specifications</h3>

        <p>Refers to the specifications created by designers to communicate the features of an entire application.
          Feature Specifications typically come in the form of high fidelity or low fidelity page or screen mockups with
          annotations describing the user experience and or interaction designs intended by the designers.</p>

        <h3>Mirco Frontends</h3>

        <p>An application architecture that results in a single application constructed from more than one application
          runtime (be it an iframe or a module that represents an application)</p>

        <h3>Non-UI Component (aka non-presentational component)</h3>

        <p>A component that has no user facing surface to it. In other words, the component has no user interface
          aspect.</p>

        <h3>Primitive UI/Presentational Components</h3>

        <p>A component built that priorities an innate reusable nature (e.g., buttons, Icons, Modals, etc.) rather than
          a specific domain use case (i.e., similar to "Atoms" from Atomic Design). Primitive components are often
          constructed to be consumed by domain components to create less general UI components.</p>

        <h3>Top-down Components</h3>

        <p>A collection of nonspecific optimistically produced components with generic cross-cutting features typically
          valued on the promise of UI unification and reuse. Think of top-down components as components that are not
          built with any specific product or application in mind but as off-the-shelf generic solutions to common UI
          patterns (e.g., a generic modal component). Few organizations can benefit or maintain a set of top-down
          components while creating custom user-centered UI's. No one component can account for all current and future
          use cases within custom UI's. Top-down component systems often fail because they are leveraged in situations
          that most often require bottom-up components. Top-down components do have a use case, but they are usually for
          prototyping, non-critical UI's, generically patterned UI's, or as plumbing to bottom-up components in the form
          of headless or unstyled UI parts (e.g., reakit.io, readix-ui.com, headlessui.dev). </p>

        <h3>UI Component (aka presentational component)</h3>

        <p>A component that has with it a user facing surface (e.g., a button component) to one degree or another even
          that surface lacks dimension but otherwise dictates how something visual appears (e.g., a <a
            href="https://ant.design/components/layout/">layout component</a>). </p>

      </div>

      <div id="chapter7" class="chapter">

        <h2>FAQ</h2>

        <h3>Can you just give me the TLTR</h3>

        <p>Component-driven software is software the is built from independently specified, built, versioned,
          documented, and tested components using a component-driven system.</p>

        <h3>Wait, are you asserting that each product/application would have its own unique collection of components?
        </h3>

        <p>Yes. This exactly the notion at the heart of component-driven software by way
          of a component-driven
          system. It is my belief that a general consensus is being reached among professionals in this space that the
          idea of a single generic top-down set of components as a system of reuse and visual
          normalization tool is mostly a failed endeavor with a limited use case. If you have only one
          product/application
          then yes created a single collection of components for the context. But, the notion that a generic top-down
          collection of components can be used to build out multiple applications/products today and in the future
          is a flawed idea in practice. It almost always fails unless what you really require in the finished product is
          a general and generic application built from general and generic design patterns.
        </p>

        <h3>Isn't this just window dressing around the idea of leveraging generic UI Toolkits?</h3>

        <p>
          If your organization has the luxury (few do) of building software from a slightly customizable off-the-shelf
          generic UI toolkit (be internally built or from a thirdparty),
          then you have already surrendered the UI to a generalized set of top-down components that come with
          pre-determined locked
          features, behaviors, and interactions.
        </p>

        <p>
          Suppose it is determined that an application will be built with something like <a
            href="https://material-ui.com/">Material-UI components</a>;
          this decision
          in many ways determines the features of the application that can be used to solve UI problems. They
          have forced
          the hands of the designers as well as the application developers because by adopting pre-built components,
          they have
          restricted the UI to a broad set of UI design solutions (i.e. Pre-built UI components have baked into them
          generalized
          solutions to
          common UI patterns). Using pre-built components as-is affects how UI's can be built to solve user interface
          problems in a
          user-centered-minded manner.
        </p>

        <p>
          Does this mean that all components in a component-driven system are custom built from the ground up. No!
          However, it
          does mean that if you are borrowing something from a third-party, <a
            href="https://github.com/codylindley/locuslabs-component-driven-system/blob/master/ui_components/VMS/primitive-components/select/index.js#L344">then
            you should wrap</a> it up in a <a
            href="https://codylindley.github.io/locuslabs-storybook/?path=/docs/vms-components-primitive-components-select--default#component-props">custom
            component</a> so
          that the details of the implementation are abstracted.
        </p>

        <p>
          Component-driven software and the system devised to support the tenets of component-driven software are
          typically
          instituted within an organization when the organization recognizes that bottom-up components are needed to
          construct
          custom user-centered UI's for individual applications that may run across various platforms and devices using
          one or more design systems.
        </p>

        <h3>Where/when does a "Design System" come into play?</h3>

        <p>I define a design system as "a set of reusable design-related rules (tokens, patterns, behaviors, language)
          as a system of instructions that can fuel various types of implementations that can or cannot be component
          driven." </p>

        <p>Design Systems are used by designers and interaction designers and come before implementations. UI components
          and theme
          components consume a Design System.</p>

        <p>Don't conflate a design system with an implementation fueled by a Design system. Design systems end where
          implementations and component-driven systems begin.</p>

        <h3>Is this just another name for a "Micro Frontend"?</h3>

        <p>I define a "Micro Frontend" to mean, "An application architecture that results in a single application
          constructed from more than one application runtime (be it an iframe or a module that represents an application
          running in the same frame)."</p>

        <p>The terms "component-driven" and "Micro Frontends" are often conflated. Don't confuse these two terms because
          subdividing software into components and subdividing software (including the UI) into separate runtimes/apps
          might share the nature of subdividing a thing but the concepts have very different purposes, costs, and
          returns. A micro frontend architecture can use components from a component-driven system just like any
          non-micro frontend architecture.</p>

        <h3>Is this just Atomic Design applied to applications made from component trees?</h3>

        <p>Atomic design is a sematic useful for drawing boundaries around UI's when creating style guides. This concept
          is somewhat of a deprecated practice given the advancements of Design Systems. In a modern sense the value of
          the semantics provided by Atomic Design devolves quickly because overly categorizing components induces mental
          model complexities and confusion when building composable components.</p>

        <p>For this reason, when thinking in terms of UI components, I have found it easier to think in terms of
          primitive UI components v.s. domain UI components. To briefly borrow and simplify Atomic Design semantics the
          only line of demarcating needed is a component is either an "Atom" or something more than an Atom. Said
          another way a component is built with the nature of composition as a first-order priority (i.e, primitive like
          a button) or not (i.e. domain like a specific header in an app that may or may not contain primitive
          components).</p>

        <p>In many ways, a proper Design System has replaced the need to think in terms of Atomic Design. A Design
          System properly fueling a component-driven system (via component specifications) should be all that is needed
          today. But make no mistake about it, Atomic Designed paved the way for Design Systems and Component-Driven
          Software.</p>

      </div>
    </div>
  </div>

  <script src="js/slideout.min.js "></script>
  <script src="js/jquery-3.3.1.slim.min.js "></script>

  <script src="js/viewer.min.js"></script><!-- Viewer.js is required -->
  <script src="js/jquery-viewer.js"></script>

  <script>
    // Create slide out TOC
    var slideout = new Slideout({
      panel: document.getElementById("panel"),
      menu: document.getElementById("menu"),
      padding: 356,
      tolerance: 70
    });

    // image viewer

    // View a list of images
    $('.images, .image').viewer();


    // Create TOC dynamically from content
    jQuery(".chapter").each(function (index) {
      jQuery("h2", "#chapter" + (index + 1)).each(function (i) {
        $(this).attr("id", index + 1);
        $("#toc").append(
          '<h5><a href="#' + (index + 1) + '">' + $(this).html() + "</a></h5>"
        );
      });

      jQuery("h3", "#chapter" + (index + 1)).each(function (i) {
        $(this).attr("id", index + 1 + "." + (i + 1));
        $("#toc").append(
          '<h6><a href="#' +
          (index + 1) +
          "." +
          (i + 1) +
          '">' +
          $(this).html() +
          "</a></h6>"
        );
      });
    });

    jQuery("#panel").on(
      "click",
      "a:not(.codesandboxlink a, .toolbar a)",
      function () {
        window.open($(this).attr("href"));
        return false;
      }
    );

    // create link to codesandob
    jQuery(".line-numbers:has(.language-js)")
      .not(":has(.noRun)")
      .before(
        '<div class="codesandboxlink"><a href="#">run/edit in codesandbox.io</a></div>'
      );

    // create event handler for codesandbox link
    jQuery("#panel").on("click", ".codesandboxlink a", function (e) {
      const code = $(this)
        .parent()
        .next(".code-toolbar:has(.language-js)")
        .find("code")
        .text();
      var newWindow = window.open("", "_blank");
      fetch("https://codesandbox.io/api/v1/sandboxes/define?json=1", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Accept: "application/json"
        },
        body: JSON.stringify({
          files: {
            "index.js": {
              content: code
            },
            "index.html": {
              content:
                '<script src="./node_modules/babel-polyfill/dist/polyfill.js"><\/script><script src="https://unpkg.com/core-js-bundle@3.0.0-beta.3/index.js"><\/script><script src="index.js"><\/script>'
            },
            ".babelrc": {
              content: {
                presets: ["env", "stage-0"]
              }
            },
            "package.json": {
              content: {
                name: "ES2015+ Enlightenment Code Example",
                version: "1.0.0",
                description: "Simple Parcel/Babel Sandbox",
                main: "index.html",
                scripts: {
                  start: "parcel index.html --open",
                  build: "parcel build index.html"
                },
                dependencies: { "babel-polyfill": "6.26.0" },
                devDependencies: {
                  "parcel-bundler": "^1.12.3",
                  "babel-preset-env": "^1.7.0",
                  "babel-preset-stage-0": "^6.24.1"
                }
              }
            }
          }
        })
      })
        .then(x => x.json())
        .then(data => {
          newWindow.location.href =
            "https://codesandbox.io/embed/" +
            data.sandbox_id +
            "?forcerefresh=1&eslint=1&expanddevtools=1&hidenavigation=1&module=%2Findex.js";
        });
      e.preventDefault();
    });

    // toggle TOC from hamburger icon
    document
      .querySelector("#menuButton")
      .addEventListener("click", function () {
        slideout.toggle();
      });

    // toggle TOC on window resize
    window.addEventListener("resize", resizeThrottler, false);
    var resizeTimeout;
    function resizeThrottler() {
      // ignore resize events as long as an actualResizeHandler execution is in the queue
      if (!resizeTimeout) {
        resizeTimeout = setTimeout(function () {
          resizeTimeout = null;
          actualResizeHandler();

          // The actualResizeHandler will execute at a rate of 15fps
        }, 66);
      }
    }
    function actualResizeHandler() {
      if (window.innerWidth > 1036) {
        slideout.open();
      } else {
        slideout.close();
      }
    }

    // open TOC on load if window is wide enough
    window.addEventListener("load", function (event) {
      if (window.innerWidth > 1036) {
        slideout.open();
      } else {
        slideout.close();
      }
    });
  </script>
</body>

</html>